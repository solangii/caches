#ifndef MIN_HEAP_H#define MIN_HEAP_Htemplate <typename T>struct MinHeap {    static int parent(int x){ //my implement 1 : return parent index        return (x-1)/2;    }    static int child(int x){ //my implement 2 : return child index        return (2*x+1);    }    static void swap(T& a, T& b){ //my implement 3 : swap two value (call by ref)        T temp = a;        a = b;        b = temp;    }    static void percolate_up(T* arr, int index){ //my implement 4 : percolate_up algorithm -  It is an algorithm that sorts according to minheap rules from index to index 0. Starting comparision between parent and child value from input index, if the value at child index is smaller than his parent value, the swap is excuted because it violates minheap rules. This is repeated until index is replaced with parent index and root (index=0). If the minheap rule is followed during iteration(the child's value is lager than the parent's value), the loop will escape and be terminated early.        while(index > 0){             int par_index = parent(index);            if(arr[index] >= arr[par_index]){                 return;            }                        else{                swap(arr[index], arr[par_index]);                index = par_index;            }        }    }    static void percolate_down(T* arr, int size, int index){ //my implement 5 : percolate down algorithm - It is an algorithm that sorts the input index to size-1 index according to minheap rules. Find the smallest value after index and swap the value of index and the smallest value, and the child value of index will repeat it until all values follow minheap's rules. If the index reaches the last index, or if the values are correctly ordered, loop ends.        int child_index = child(index);        T cur_value = arr[index];        while(child_index < size){             T min = cur_value;            int min_index = -1;            for(int i=0; i<2 && i+child_index < size; i++){ // repeat two child                if(arr[i+child_index] < min){ //to find minimum value                    min = arr[i+child_index];                    min_index = i +child_index;                }            }            if(min == cur_value){ //terminate condition                 return;            }            else{ //repeat until find the minimum value                swap(arr[index], arr[min_index]);                index = min_index;                child_index = child(index);            }        }    }    static void heapify(T* arr, int size){ //my implement 6 : heapify array - Compare the values from the first index to size-1 index with values in the parent index. If there is a relationship that violates the minheap rules,reorder it through percolate up.        for(int i=1; i<size; i++){            int cur_index = i;            int par_index = parent(cur_index);            if(arr[cur_index] < arr[par_index]){                percolate_up(arr, cur_index);            }        }    }    static void make_heap(T* arr, int size, int hint = -1) {// Build heap - It is an algorithm heapify the entered array. If the hint exists in range(0~size-1), only the value in the hint index needs to be heapfy. So i can sort it using percolate algorithm. If hint is not given, use the heapify function to heapify.        if(hint>=0 && hint<size ){             percolate_down(arr, size, hint);            percolate_up(arr, hint);        }        else heapify(arr, size);    }    static void pop(T* arr, int size) { // Delete minimum - Delete the smallest value in the heap(here is the value at index 0). It is difficult to apply concept of delete in an array already declared in size, so here is implemented in a way that is exchanged for the last value(the value at index size-1) and does not approach the size-1 index. Also, since the size of the value(at index 0) has changed, the minheap is reordered again from index 0 through percolate down.        swap(arr[0],arr[size-1]);        percolate_down(arr, size-1, 0);    }    static void push(T*	arr, int size, T item) { // Push item - Push item to arr[size] Then, to consider the rules of minheap, run the percolate up(at that time index is size).(Also, I didn't consider the situation that push is excuted when the array is full.)        arr[size] = item;        percolate_up(arr, size);    }};#endif